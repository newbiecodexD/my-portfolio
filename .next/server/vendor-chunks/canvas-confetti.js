"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-confetti";
exports.ids = ["vendor-chunks/canvas-confetti"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.9.3 built on 2024-04-30T22:19:17.794Z\nvar module = {};\n// source content\n/* globals Map */ (function main(global, module, isWorker, workerSize) {\n    var canUseWorker = !!(global.Worker && global.Blob && global.Promise && global.OffscreenCanvas && global.OffscreenCanvasRenderingContext2D && global.HTMLCanvasElement && global.HTMLCanvasElement.prototype.transferControlToOffscreen && global.URL && global.URL.createObjectURL);\n    var canUsePaths = typeof Path2D === \"function\" && typeof DOMMatrix === \"function\";\n    var canDrawBitmap = function() {\n        // this mostly supports ssr\n        if (!global.OffscreenCanvas) {\n            return false;\n        }\n        var canvas = new OffscreenCanvas(1, 1);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.fillRect(0, 0, 1, 1);\n        var bitmap = canvas.transferToImageBitmap();\n        try {\n            ctx.createPattern(bitmap, \"no-repeat\");\n        } catch (e) {\n            return false;\n        }\n        return true;\n    }();\n    function noop() {}\n    // create a promise if it exists, otherwise, just\n    // call the function directly\n    function promise(func) {\n        var ModulePromise = module.exports.Promise;\n        var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\n        if (typeof Prom === \"function\") {\n            return new Prom(func);\n        }\n        func(noop, noop);\n        return null;\n    }\n    var bitmapMapper = function(skipTransform, map) {\n        // see https://github.com/catdad/canvas-confetti/issues/209\n        // creating canvases is actually pretty expensive, so we should create a\n        // 1:1 map for bitmap:canvas, so that we can animate the confetti in\n        // a performant manner, but also not store them forever so that we don't\n        // have a memory leak\n        return {\n            transform: function(bitmap) {\n                if (skipTransform) {\n                    return bitmap;\n                }\n                if (map.has(bitmap)) {\n                    return map.get(bitmap);\n                }\n                var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.drawImage(bitmap, 0, 0);\n                map.set(bitmap, canvas);\n                return canvas;\n            },\n            clear: function() {\n                map.clear();\n            }\n        };\n    }(canDrawBitmap, new Map());\n    var raf = function() {\n        var TIME = Math.floor(1000 / 60);\n        var frame, cancel;\n        var frames = {};\n        var lastFrameTime = 0;\n        if (typeof requestAnimationFrame === \"function\" && typeof cancelAnimationFrame === \"function\") {\n            frame = function(cb) {\n                var id = Math.random();\n                frames[id] = requestAnimationFrame(function onFrame(time) {\n                    if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\n                        lastFrameTime = time;\n                        delete frames[id];\n                        cb();\n                    } else {\n                        frames[id] = requestAnimationFrame(onFrame);\n                    }\n                });\n                return id;\n            };\n            cancel = function(id) {\n                if (frames[id]) {\n                    cancelAnimationFrame(frames[id]);\n                }\n            };\n        } else {\n            frame = function(cb) {\n                return setTimeout(cb, TIME);\n            };\n            cancel = function(timer) {\n                return clearTimeout(timer);\n            };\n        }\n        return {\n            frame: frame,\n            cancel: cancel\n        };\n    }();\n    var getWorker = function() {\n        var worker;\n        var prom;\n        var resolves = {};\n        function decorate(worker) {\n            function execute(options, callback) {\n                worker.postMessage({\n                    options: options || {},\n                    callback: callback\n                });\n            }\n            worker.init = function initWorker(canvas) {\n                var offscreen = canvas.transferControlToOffscreen();\n                worker.postMessage({\n                    canvas: offscreen\n                }, [\n                    offscreen\n                ]);\n            };\n            worker.fire = function fireWorker(options, size, done) {\n                if (prom) {\n                    execute(options, null);\n                    return prom;\n                }\n                var id = Math.random().toString(36).slice(2);\n                prom = promise(function(resolve) {\n                    function workerDone(msg) {\n                        if (msg.data.callback !== id) {\n                            return;\n                        }\n                        delete resolves[id];\n                        worker.removeEventListener(\"message\", workerDone);\n                        prom = null;\n                        bitmapMapper.clear();\n                        done();\n                        resolve();\n                    }\n                    worker.addEventListener(\"message\", workerDone);\n                    execute(options, id);\n                    resolves[id] = workerDone.bind(null, {\n                        data: {\n                            callback: id\n                        }\n                    });\n                });\n                return prom;\n            };\n            worker.reset = function resetWorker() {\n                worker.postMessage({\n                    reset: true\n                });\n                for(var id in resolves){\n                    resolves[id]();\n                    delete resolves[id];\n                }\n            };\n        }\n        return function() {\n            if (worker) {\n                return worker;\n            }\n            if (!isWorker && canUseWorker) {\n                var code = [\n                    \"var CONFETTI, SIZE = {}, module = {};\",\n                    \"(\" + main.toString() + \")(this, module, true, SIZE);\",\n                    \"onmessage = function(msg) {\",\n                    \"  if (msg.data.options) {\",\n                    \"    CONFETTI(msg.data.options).then(function () {\",\n                    \"      if (msg.data.callback) {\",\n                    \"        postMessage({ callback: msg.data.callback });\",\n                    \"      }\",\n                    \"    });\",\n                    \"  } else if (msg.data.reset) {\",\n                    \"    CONFETTI && CONFETTI.reset();\",\n                    \"  } else if (msg.data.resize) {\",\n                    \"    SIZE.width = msg.data.resize.width;\",\n                    \"    SIZE.height = msg.data.resize.height;\",\n                    \"  } else if (msg.data.canvas) {\",\n                    \"    SIZE.width = msg.data.canvas.width;\",\n                    \"    SIZE.height = msg.data.canvas.height;\",\n                    \"    CONFETTI = module.exports.create(msg.data.canvas);\",\n                    \"  }\",\n                    \"}\"\n                ].join(\"\\n\");\n                try {\n                    worker = new Worker(URL.createObjectURL(new Blob([\n                        code\n                    ])));\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    typeof console !== undefined && typeof console.warn === \"function\" ? console.warn(\"\\uD83C\\uDF8A Could not load worker\", e) : null;\n                    return null;\n                }\n                decorate(worker);\n            }\n            return worker;\n        };\n    }();\n    var defaults = {\n        particleCount: 50,\n        angle: 90,\n        spread: 45,\n        startVelocity: 45,\n        decay: 0.9,\n        gravity: 1,\n        drift: 0,\n        ticks: 200,\n        x: 0.5,\n        y: 0.5,\n        shapes: [\n            \"square\",\n            \"circle\"\n        ],\n        zIndex: 100,\n        colors: [\n            \"#26ccff\",\n            \"#a25afd\",\n            \"#ff5e7e\",\n            \"#88ff5a\",\n            \"#fcff42\",\n            \"#ffa62d\",\n            \"#ff36ff\"\n        ],\n        // probably should be true, but back-compat\n        disableForReducedMotion: false,\n        scalar: 1\n    };\n    function convert(val, transform) {\n        return transform ? transform(val) : val;\n    }\n    function isOk(val) {\n        return !(val === null || val === undefined);\n    }\n    function prop(options, name, transform) {\n        return convert(options && isOk(options[name]) ? options[name] : defaults[name], transform);\n    }\n    function onlyPositiveInt(number) {\n        return number < 0 ? 0 : Math.floor(number);\n    }\n    function randomInt(min, max) {\n        // [min, max)\n        return Math.floor(Math.random() * (max - min)) + min;\n    }\n    function toDecimal(str) {\n        return parseInt(str, 16);\n    }\n    function colorsToRgb(colors) {\n        return colors.map(hexToRgb);\n    }\n    function hexToRgb(str) {\n        var val = String(str).replace(/[^0-9a-f]/gi, \"\");\n        if (val.length < 6) {\n            val = val[0] + val[0] + val[1] + val[1] + val[2] + val[2];\n        }\n        return {\n            r: toDecimal(val.substring(0, 2)),\n            g: toDecimal(val.substring(2, 4)),\n            b: toDecimal(val.substring(4, 6))\n        };\n    }\n    function getOrigin(options) {\n        var origin = prop(options, \"origin\", Object);\n        origin.x = prop(origin, \"x\", Number);\n        origin.y = prop(origin, \"y\", Number);\n        return origin;\n    }\n    function setCanvasWindowSize(canvas) {\n        canvas.width = document.documentElement.clientWidth;\n        canvas.height = document.documentElement.clientHeight;\n    }\n    function setCanvasRectSize(canvas) {\n        var rect = canvas.getBoundingClientRect();\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n    }\n    function getCanvas(zIndex) {\n        var canvas = document.createElement(\"canvas\");\n        canvas.style.position = \"fixed\";\n        canvas.style.top = \"0px\";\n        canvas.style.left = \"0px\";\n        canvas.style.pointerEvents = \"none\";\n        canvas.style.zIndex = zIndex;\n        return canvas;\n    }\n    function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n        context.save();\n        context.translate(x, y);\n        context.rotate(rotation);\n        context.scale(radiusX, radiusY);\n        context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n        context.restore();\n    }\n    function randomPhysics(opts) {\n        var radAngle = opts.angle * (Math.PI / 180);\n        var radSpread = opts.spread * (Math.PI / 180);\n        return {\n            x: opts.x,\n            y: opts.y,\n            wobble: Math.random() * 10,\n            wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\n            velocity: opts.startVelocity * 0.5 + Math.random() * opts.startVelocity,\n            angle2D: -radAngle + (0.5 * radSpread - Math.random() * radSpread),\n            tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\n            color: opts.color,\n            shape: opts.shape,\n            tick: 0,\n            totalTicks: opts.ticks,\n            decay: opts.decay,\n            drift: opts.drift,\n            random: Math.random() + 2,\n            tiltSin: 0,\n            tiltCos: 0,\n            wobbleX: 0,\n            wobbleY: 0,\n            gravity: opts.gravity * 3,\n            ovalScalar: 0.6,\n            scalar: opts.scalar,\n            flat: opts.flat\n        };\n    }\n    function updateFetti(context, fetti) {\n        fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\n        fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\n        fetti.velocity *= fetti.decay;\n        if (fetti.flat) {\n            fetti.wobble = 0;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar;\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar;\n            fetti.tiltSin = 0;\n            fetti.tiltCos = 0;\n            fetti.random = 1;\n        } else {\n            fetti.wobble += fetti.wobbleSpeed;\n            fetti.wobbleX = fetti.x + 10 * fetti.scalar * Math.cos(fetti.wobble);\n            fetti.wobbleY = fetti.y + 10 * fetti.scalar * Math.sin(fetti.wobble);\n            fetti.tiltAngle += 0.1;\n            fetti.tiltSin = Math.sin(fetti.tiltAngle);\n            fetti.tiltCos = Math.cos(fetti.tiltAngle);\n            fetti.random = Math.random() + 2;\n        }\n        var progress = fetti.tick++ / fetti.totalTicks;\n        var x1 = fetti.x + fetti.random * fetti.tiltCos;\n        var y1 = fetti.y + fetti.random * fetti.tiltSin;\n        var x2 = fetti.wobbleX + fetti.random * fetti.tiltCos;\n        var y2 = fetti.wobbleY + fetti.random * fetti.tiltSin;\n        context.fillStyle = \"rgba(\" + fetti.color.r + \", \" + fetti.color.g + \", \" + fetti.color.b + \", \" + (1 - progress) + \")\";\n        context.beginPath();\n        if (canUsePaths && fetti.shape.type === \"path\" && typeof fetti.shape.path === \"string\" && Array.isArray(fetti.shape.matrix)) {\n            context.fill(transformPath2D(fetti.shape.path, fetti.shape.matrix, fetti.x, fetti.y, Math.abs(x2 - x1) * 0.1, Math.abs(y2 - y1) * 0.1, Math.PI / 10 * fetti.wobble));\n        } else if (fetti.shape.type === \"bitmap\") {\n            var rotation = Math.PI / 10 * fetti.wobble;\n            var scaleX = Math.abs(x2 - x1) * 0.1;\n            var scaleY = Math.abs(y2 - y1) * 0.1;\n            var width = fetti.shape.bitmap.width * fetti.scalar;\n            var height = fetti.shape.bitmap.height * fetti.scalar;\n            var matrix = new DOMMatrix([\n                Math.cos(rotation) * scaleX,\n                Math.sin(rotation) * scaleX,\n                -Math.sin(rotation) * scaleY,\n                Math.cos(rotation) * scaleY,\n                fetti.x,\n                fetti.y\n            ]);\n            // apply the transform matrix from the confetti shape\n            matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\n            var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), \"no-repeat\");\n            pattern.setTransform(matrix);\n            context.globalAlpha = 1 - progress;\n            context.fillStyle = pattern;\n            context.fillRect(fetti.x - width / 2, fetti.y - height / 2, width, height);\n            context.globalAlpha = 1;\n        } else if (fetti.shape === \"circle\") {\n            context.ellipse ? context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) : ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\n        } else if (fetti.shape === \"star\") {\n            var rot = Math.PI / 2 * 3;\n            var innerRadius = 4 * fetti.scalar;\n            var outerRadius = 8 * fetti.scalar;\n            var x = fetti.x;\n            var y = fetti.y;\n            var spikes = 5;\n            var step = Math.PI / spikes;\n            while(spikes--){\n                x = fetti.x + Math.cos(rot) * outerRadius;\n                y = fetti.y + Math.sin(rot) * outerRadius;\n                context.lineTo(x, y);\n                rot += step;\n                x = fetti.x + Math.cos(rot) * innerRadius;\n                y = fetti.y + Math.sin(rot) * innerRadius;\n                context.lineTo(x, y);\n                rot += step;\n            }\n        } else {\n            context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\n            context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\n            context.lineTo(Math.floor(x2), Math.floor(y2));\n            context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\n        }\n        context.closePath();\n        context.fill();\n        return fetti.tick < fetti.totalTicks;\n    }\n    function animate(canvas, fettis, resizer, size, done) {\n        var animatingFettis = fettis.slice();\n        var context = canvas.getContext(\"2d\");\n        var animationFrame;\n        var destroy;\n        var prom = promise(function(resolve) {\n            function onDone() {\n                animationFrame = destroy = null;\n                context.clearRect(0, 0, size.width, size.height);\n                bitmapMapper.clear();\n                done();\n                resolve();\n            }\n            function update() {\n                if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\n                    size.width = canvas.width = workerSize.width;\n                    size.height = canvas.height = workerSize.height;\n                }\n                if (!size.width && !size.height) {\n                    resizer(canvas);\n                    size.width = canvas.width;\n                    size.height = canvas.height;\n                }\n                context.clearRect(0, 0, size.width, size.height);\n                animatingFettis = animatingFettis.filter(function(fetti) {\n                    return updateFetti(context, fetti);\n                });\n                if (animatingFettis.length) {\n                    animationFrame = raf.frame(update);\n                } else {\n                    onDone();\n                }\n            }\n            animationFrame = raf.frame(update);\n            destroy = onDone;\n        });\n        return {\n            addFettis: function(fettis) {\n                animatingFettis = animatingFettis.concat(fettis);\n                return prom;\n            },\n            canvas: canvas,\n            promise: prom,\n            reset: function() {\n                if (animationFrame) {\n                    raf.cancel(animationFrame);\n                }\n                if (destroy) {\n                    destroy();\n                }\n            }\n        };\n    }\n    function confettiCannon(canvas, globalOpts) {\n        var isLibCanvas = !canvas;\n        var allowResize = !!prop(globalOpts || {}, \"resize\");\n        var hasResizeEventRegistered = false;\n        var globalDisableForReducedMotion = prop(globalOpts, \"disableForReducedMotion\", Boolean);\n        var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, \"useWorker\");\n        var worker = shouldUseWorker ? getWorker() : null;\n        var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\n        var initialized = canvas && worker ? !!canvas.__confetti_initialized : false;\n        var preferLessMotion = typeof matchMedia === \"function\" && matchMedia(\"(prefers-reduced-motion)\").matches;\n        var animationObj;\n        function fireLocal(options, size, done) {\n            var particleCount = prop(options, \"particleCount\", onlyPositiveInt);\n            var angle = prop(options, \"angle\", Number);\n            var spread = prop(options, \"spread\", Number);\n            var startVelocity = prop(options, \"startVelocity\", Number);\n            var decay = prop(options, \"decay\", Number);\n            var gravity = prop(options, \"gravity\", Number);\n            var drift = prop(options, \"drift\", Number);\n            var colors = prop(options, \"colors\", colorsToRgb);\n            var ticks = prop(options, \"ticks\", Number);\n            var shapes = prop(options, \"shapes\");\n            var scalar = prop(options, \"scalar\");\n            var flat = !!prop(options, \"flat\");\n            var origin = getOrigin(options);\n            var temp = particleCount;\n            var fettis = [];\n            var startX = canvas.width * origin.x;\n            var startY = canvas.height * origin.y;\n            while(temp--){\n                fettis.push(randomPhysics({\n                    x: startX,\n                    y: startY,\n                    angle: angle,\n                    spread: spread,\n                    startVelocity: startVelocity,\n                    color: colors[temp % colors.length],\n                    shape: shapes[randomInt(0, shapes.length)],\n                    ticks: ticks,\n                    decay: decay,\n                    gravity: gravity,\n                    drift: drift,\n                    scalar: scalar,\n                    flat: flat\n                }));\n            }\n            // if we have a previous canvas already animating,\n            // add to it\n            if (animationObj) {\n                return animationObj.addFettis(fettis);\n            }\n            animationObj = animate(canvas, fettis, resizer, size, done);\n            return animationObj.promise;\n        }\n        function fire(options) {\n            var disableForReducedMotion = globalDisableForReducedMotion || prop(options, \"disableForReducedMotion\", Boolean);\n            var zIndex = prop(options, \"zIndex\", Number);\n            if (disableForReducedMotion && preferLessMotion) {\n                return promise(function(resolve) {\n                    resolve();\n                });\n            }\n            if (isLibCanvas && animationObj) {\n                // use existing canvas from in-progress animation\n                canvas = animationObj.canvas;\n            } else if (isLibCanvas && !canvas) {\n                // create and initialize a new canvas\n                canvas = getCanvas(zIndex);\n                document.body.appendChild(canvas);\n            }\n            if (allowResize && !initialized) {\n                // initialize the size of a user-supplied canvas\n                resizer(canvas);\n            }\n            var size = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            if (worker && !initialized) {\n                worker.init(canvas);\n            }\n            initialized = true;\n            if (worker) {\n                canvas.__confetti_initialized = true;\n            }\n            function onResize() {\n                if (worker) {\n                    // TODO this really shouldn't be immediate, because it is expensive\n                    var obj = {\n                        getBoundingClientRect: function() {\n                            if (!isLibCanvas) {\n                                return canvas.getBoundingClientRect();\n                            }\n                        }\n                    };\n                    resizer(obj);\n                    worker.postMessage({\n                        resize: {\n                            width: obj.width,\n                            height: obj.height\n                        }\n                    });\n                    return;\n                }\n                // don't actually query the size here, since this\n                // can execute frequently and rapidly\n                size.width = size.height = null;\n            }\n            function done() {\n                animationObj = null;\n                if (allowResize) {\n                    hasResizeEventRegistered = false;\n                    global.removeEventListener(\"resize\", onResize);\n                }\n                if (isLibCanvas && canvas) {\n                    if (document.body.contains(canvas)) {\n                        document.body.removeChild(canvas);\n                    }\n                    canvas = null;\n                    initialized = false;\n                }\n            }\n            if (allowResize && !hasResizeEventRegistered) {\n                hasResizeEventRegistered = true;\n                global.addEventListener(\"resize\", onResize, false);\n            }\n            if (worker) {\n                return worker.fire(options, size, done);\n            }\n            return fireLocal(options, size, done);\n        }\n        fire.reset = function() {\n            if (worker) {\n                worker.reset();\n            }\n            if (animationObj) {\n                animationObj.reset();\n            }\n        };\n        return fire;\n    }\n    // Make default export lazy to defer worker creation until called.\n    var defaultFire;\n    function getDefaultFire() {\n        if (!defaultFire) {\n            defaultFire = confettiCannon(null, {\n                useWorker: true,\n                resize: true\n            });\n        }\n        return defaultFire;\n    }\n    function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\n        var path2d = new Path2D(pathString);\n        var t1 = new Path2D();\n        t1.addPath(path2d, new DOMMatrix(pathMatrix));\n        var t2 = new Path2D();\n        // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\n        t2.addPath(t1, new DOMMatrix([\n            Math.cos(rotation) * scaleX,\n            Math.sin(rotation) * scaleX,\n            -Math.sin(rotation) * scaleY,\n            Math.cos(rotation) * scaleY,\n            x,\n            y\n        ]));\n        return t2;\n    }\n    function shapeFromPath(pathData) {\n        if (!canUsePaths) {\n            throw new Error(\"path confetti are not supported in this browser\");\n        }\n        var path, matrix;\n        if (typeof pathData === \"string\") {\n            path = pathData;\n        } else {\n            path = pathData.path;\n            matrix = pathData.matrix;\n        }\n        var path2d = new Path2D(path);\n        var tempCanvas = document.createElement(\"canvas\");\n        var tempCtx = tempCanvas.getContext(\"2d\");\n        if (!matrix) {\n            // attempt to figure out the width of the path, up to 1000x1000\n            var maxSize = 1000;\n            var minX = maxSize;\n            var minY = maxSize;\n            var maxX = 0;\n            var maxY = 0;\n            var width, height;\n            // do some line skipping... this is faster than checking\n            // every pixel and will be mostly still correct\n            for(var x = 0; x < maxSize; x += 2){\n                for(var y = 0; y < maxSize; y += 2){\n                    if (tempCtx.isPointInPath(path2d, x, y, \"nonzero\")) {\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            width = maxX - minX;\n            height = maxY - minY;\n            var maxDesiredSize = 10;\n            var scale = Math.min(maxDesiredSize / width, maxDesiredSize / height);\n            matrix = [\n                scale,\n                0,\n                0,\n                scale,\n                -Math.round(width / 2 + minX) * scale,\n                -Math.round(height / 2 + minY) * scale\n            ];\n        }\n        return {\n            type: \"path\",\n            path: path,\n            matrix: matrix\n        };\n    }\n    function shapeFromText(textData) {\n        var text, scalar = 1, color = \"#000000\", // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\n        fontFamily = '\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\", \"Twemoji Mozilla\", \"system emoji\", sans-serif';\n        if (typeof textData === \"string\") {\n            text = textData;\n        } else {\n            text = textData.text;\n            scalar = \"scalar\" in textData ? textData.scalar : scalar;\n            fontFamily = \"fontFamily\" in textData ? textData.fontFamily : fontFamily;\n            color = \"color\" in textData ? textData.color : color;\n        }\n        // all other confetti are 10 pixels,\n        // so this pixel size is the de-facto 100% scale confetti\n        var fontSize = 10 * scalar;\n        var font = \"\" + fontSize + \"px \" + fontFamily;\n        var canvas = new OffscreenCanvas(fontSize, fontSize);\n        var ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        var size = ctx.measureText(text);\n        var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\n        var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\n        var padding = 2;\n        var x = size.actualBoundingBoxLeft + padding;\n        var y = size.actualBoundingBoxAscent + padding;\n        width += padding + padding;\n        height += padding + padding;\n        canvas = new OffscreenCanvas(width, height);\n        ctx = canvas.getContext(\"2d\");\n        ctx.font = font;\n        ctx.fillStyle = color;\n        ctx.fillText(text, x, y);\n        var scale = 1 / scalar;\n        return {\n            type: \"bitmap\",\n            // TODO these probably need to be transfered for workers\n            bitmap: canvas.transferToImageBitmap(),\n            matrix: [\n                scale,\n                0,\n                0,\n                scale,\n                -width * scale / 2,\n                -height * scale / 2\n            ]\n        };\n    }\n    module.exports = function() {\n        return getDefaultFire().apply(this, arguments);\n    };\n    module.exports.reset = function() {\n        getDefaultFire().reset();\n    };\n    module.exports.create = confettiCannon;\n    module.exports.shapeFromPath = shapeFromPath;\n    module.exports.shapeFromText = shapeFromText;\n})(function() {\n    if (false) {}\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    return this || {};\n}(), module, false);\n// end source content\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\nvar create = module.exports.create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDJEQUEyRDtBQUMzRCxJQUFJQSxTQUFTLENBQUM7QUFFZCxpQkFBaUI7QUFDakIsZUFBZSxHQUVkLFVBQVNDLEtBQUtDLE1BQU0sRUFBRUYsTUFBTSxFQUFFRyxRQUFRLEVBQUVDLFVBQVU7SUFDakQsSUFBSUMsZUFBZSxDQUFDLENBQ2xCSCxDQUFBQSxPQUFPSSxNQUFNLElBQ2JKLE9BQU9LLElBQUksSUFDWEwsT0FBT00sT0FBTyxJQUNkTixPQUFPTyxlQUFlLElBQ3RCUCxPQUFPUSxpQ0FBaUMsSUFDeENSLE9BQU9TLGlCQUFpQixJQUN4QlQsT0FBT1MsaUJBQWlCLENBQUNDLFNBQVMsQ0FBQ0MsMEJBQTBCLElBQzdEWCxPQUFPWSxHQUFHLElBQ1ZaLE9BQU9ZLEdBQUcsQ0FBQ0MsZUFBZTtJQUU1QixJQUFJQyxjQUFjLE9BQU9DLFdBQVcsY0FBYyxPQUFPQyxjQUFjO0lBQ3ZFLElBQUlDLGdCQUFnQjtRQUNsQiwyQkFBMkI7UUFDM0IsSUFBSSxDQUFDakIsT0FBT08sZUFBZSxFQUFFO1lBQzNCLE9BQU87UUFDVDtRQUVBLElBQUlXLFNBQVMsSUFBSVgsZ0JBQWdCLEdBQUc7UUFDcEMsSUFBSVksTUFBTUQsT0FBT0UsVUFBVSxDQUFDO1FBQzVCRCxJQUFJRSxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7UUFDdEIsSUFBSUMsU0FBU0osT0FBT0sscUJBQXFCO1FBRXpDLElBQUk7WUFDRkosSUFBSUssYUFBYSxDQUFDRixRQUFRO1FBQzVCLEVBQUUsT0FBT0csR0FBRztZQUNWLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBLFNBQVNDLFFBQVE7SUFFakIsaURBQWlEO0lBQ2pELDZCQUE2QjtJQUM3QixTQUFTQyxRQUFRQyxJQUFJO1FBQ25CLElBQUlDLGdCQUFnQi9CLE9BQU9nQyxPQUFPLENBQUN4QixP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QUFNLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcz9mMWU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNhbnZhcy1jb25mZXR0aSB2MS45LjMgYnVpbHQgb24gMjAyNC0wNC0zMFQyMjoxOToxNy43OTRaXG52YXIgbW9kdWxlID0ge307XG5cbi8vIHNvdXJjZSBjb250ZW50XG4vKiBnbG9iYWxzIE1hcCAqL1xuXG4oZnVuY3Rpb24gbWFpbihnbG9iYWwsIG1vZHVsZSwgaXNXb3JrZXIsIHdvcmtlclNpemUpIHtcbiAgdmFyIGNhblVzZVdvcmtlciA9ICEhKFxuICAgIGdsb2JhbC5Xb3JrZXIgJiZcbiAgICBnbG9iYWwuQmxvYiAmJlxuICAgIGdsb2JhbC5Qcm9taXNlICYmXG4gICAgZ2xvYmFsLk9mZnNjcmVlbkNhbnZhcyAmJlxuICAgIGdsb2JhbC5PZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgJiZcbiAgICBnbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQgJiZcbiAgICBnbG9iYWwuSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuICYmXG4gICAgZ2xvYmFsLlVSTCAmJlxuICAgIGdsb2JhbC5VUkwuY3JlYXRlT2JqZWN0VVJMKTtcblxuICB2YXIgY2FuVXNlUGF0aHMgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBET01NYXRyaXggPT09ICdmdW5jdGlvbic7XG4gIHZhciBjYW5EcmF3Qml0bWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGlzIG1vc3RseSBzdXBwb3J0cyBzc3JcbiAgICBpZiAoIWdsb2JhbC5PZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHZhciBiaXRtYXAgPSBjYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG5cbiAgICB0cnkge1xuICAgICAgY3R4LmNyZWF0ZVBhdHRlcm4oYml0bWFwLCAnbm8tcmVwZWF0Jyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIC8vIGNyZWF0ZSBhIHByb21pc2UgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UsIGp1c3RcbiAgLy8gY2FsbCB0aGUgZnVuY3Rpb24gZGlyZWN0bHlcbiAgZnVuY3Rpb24gcHJvbWlzZShmdW5jKSB7XG4gICAgdmFyIE1vZHVsZVByb21pc2UgPSBtb2R1bGUuZXhwb3J0cy5Qcm9taXNlO1xuICAgIHZhciBQcm9tID0gTW9kdWxlUHJvbWlzZSAhPT0gdm9pZCAwID8gTW9kdWxlUHJvbWlzZSA6IGdsb2JhbC5Qcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBQcm9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb20oZnVuYyk7XG4gICAgfVxuXG4gICAgZnVuYyhub29wLCBub29wKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGJpdG1hcE1hcHBlciA9IChmdW5jdGlvbiAoc2tpcFRyYW5zZm9ybSwgbWFwKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXRkYWQvY2FudmFzLWNvbmZldHRpL2lzc3Vlcy8yMDlcbiAgICAvLyBjcmVhdGluZyBjYW52YXNlcyBpcyBhY3R1YWxseSBwcmV0dHkgZXhwZW5zaXZlLCBzbyB3ZSBzaG91bGQgY3JlYXRlIGFcbiAgICAvLyAxOjEgbWFwIGZvciBiaXRtYXA6Y2FudmFzLCBzbyB0aGF0IHdlIGNhbiBhbmltYXRlIHRoZSBjb25mZXR0aSBpblxuICAgIC8vIGEgcGVyZm9ybWFudCBtYW5uZXIsIGJ1dCBhbHNvIG5vdCBzdG9yZSB0aGVtIGZvcmV2ZXIgc28gdGhhdCB3ZSBkb24ndFxuICAgIC8vIGhhdmUgYSBtZW1vcnkgbGVha1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKGJpdG1hcCkge1xuICAgICAgICBpZiAoc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICAgIHJldHVybiBiaXRtYXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFwLmhhcyhiaXRtYXApKSB7XG4gICAgICAgICAgcmV0dXJuIG1hcC5nZXQoYml0bWFwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuXG4gICAgICAgIG1hcC5zZXQoYml0bWFwLCBjYW52YXMpO1xuXG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9LFxuICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWFwLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoY2FuRHJhd0JpdG1hcCwgbmV3IE1hcCgpKTtcblxuICB2YXIgcmFmID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgVElNRSA9IE1hdGguZmxvb3IoMTAwMCAvIDYwKTtcbiAgICB2YXIgZnJhbWUsIGNhbmNlbDtcbiAgICB2YXIgZnJhbWVzID0ge307XG4gICAgdmFyIGxhc3RGcmFtZVRpbWUgPSAwO1xuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmcmFtZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgaWQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIGZyYW1lc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gb25GcmFtZSh0aW1lKSB7XG4gICAgICAgICAgaWYgKGxhc3RGcmFtZVRpbWUgPT09IHRpbWUgfHwgbGFzdEZyYW1lVGltZSArIFRJTUUgLSAxIDwgdGltZSkge1xuICAgICAgICAgICAgbGFzdEZyYW1lVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBkZWxldGUgZnJhbWVzW2lkXTtcblxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhbWVzW2lkXSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH07XG4gICAgICBjYW5jZWwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKGZyYW1lc1tpZF0pIHtcbiAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZXNbaWRdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoY2IsIFRJTUUpO1xuICAgICAgfTtcbiAgICAgIGNhbmNlbCA9IGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZnJhbWU6IGZyYW1lLCBjYW5jZWw6IGNhbmNlbCB9O1xuICB9KCkpO1xuXG4gIHZhciBnZXRXb3JrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB3b3JrZXI7XG4gICAgdmFyIHByb207XG4gICAgdmFyIHJlc29sdmVzID0ge307XG5cbiAgICBmdW5jdGlvbiBkZWNvcmF0ZSh3b3JrZXIpIHtcbiAgICAgIGZ1bmN0aW9uIGV4ZWN1dGUob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgb3B0aW9uczogb3B0aW9ucyB8fCB7fSwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuICAgICAgfVxuICAgICAgd29ya2VyLmluaXQgPSBmdW5jdGlvbiBpbml0V29ya2VyKGNhbnZhcykge1xuICAgICAgICB2YXIgb2Zmc2NyZWVuID0gY2FudmFzLnRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuKCk7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IGNhbnZhczogb2Zmc2NyZWVuIH0sIFtvZmZzY3JlZW5dKTtcbiAgICAgIH07XG5cbiAgICAgIHdvcmtlci5maXJlID0gZnVuY3Rpb24gZmlyZVdvcmtlcihvcHRpb25zLCBzaXplLCBkb25lKSB7XG4gICAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgICAgZXhlY3V0ZShvcHRpb25zLCBudWxsKTtcbiAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4gICAgICAgIHByb20gPSBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgZnVuY3Rpb24gd29ya2VyRG9uZShtc2cpIHtcbiAgICAgICAgICAgIGlmIChtc2cuZGF0YS5jYWxsYmFjayAhPT0gaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgcmVzb2x2ZXNbaWRdO1xuICAgICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB3b3JrZXJEb25lKTtcblxuICAgICAgICAgICAgcHJvbSA9IG51bGw7XG5cbiAgICAgICAgICAgIGJpdG1hcE1hcHBlci5jbGVhcigpO1xuXG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB3b3JrZXJEb25lKTtcbiAgICAgICAgICBleGVjdXRlKG9wdGlvbnMsIGlkKTtcblxuICAgICAgICAgIHJlc29sdmVzW2lkXSA9IHdvcmtlckRvbmUuYmluZChudWxsLCB7IGRhdGE6IHsgY2FsbGJhY2s6IGlkIH19KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb207XG4gICAgICB9O1xuXG4gICAgICB3b3JrZXIucmVzZXQgPSBmdW5jdGlvbiByZXNldFdvcmtlcigpIHtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgcmVzZXQ6IHRydWUgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaWQgaW4gcmVzb2x2ZXMpIHtcbiAgICAgICAgICByZXNvbHZlc1tpZF0oKTtcbiAgICAgICAgICBkZWxldGUgcmVzb2x2ZXNbaWRdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNXb3JrZXIgJiYgY2FuVXNlV29ya2VyKSB7XG4gICAgICAgIHZhciBjb2RlID0gW1xuICAgICAgICAgICd2YXIgQ09ORkVUVEksIFNJWkUgPSB7fSwgbW9kdWxlID0ge307JyxcbiAgICAgICAgICAnKCcgKyBtYWluLnRvU3RyaW5nKCkgKyAnKSh0aGlzLCBtb2R1bGUsIHRydWUsIFNJWkUpOycsXG4gICAgICAgICAgJ29ubWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykgeycsXG4gICAgICAgICAgJyAgaWYgKG1zZy5kYXRhLm9wdGlvbnMpIHsnLFxuICAgICAgICAgICcgICAgQ09ORkVUVEkobXNnLmRhdGEub3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7JyxcbiAgICAgICAgICAnICAgICAgaWYgKG1zZy5kYXRhLmNhbGxiYWNrKSB7JyxcbiAgICAgICAgICAnICAgICAgICBwb3N0TWVzc2FnZSh7IGNhbGxiYWNrOiBtc2cuZGF0YS5jYWxsYmFjayB9KTsnLFxuICAgICAgICAgICcgICAgICB9JyxcbiAgICAgICAgICAnICAgIH0pOycsXG4gICAgICAgICAgJyAgfSBlbHNlIGlmIChtc2cuZGF0YS5yZXNldCkgeycsXG4gICAgICAgICAgJyAgICBDT05GRVRUSSAmJiBDT05GRVRUSS5yZXNldCgpOycsXG4gICAgICAgICAgJyAgfSBlbHNlIGlmIChtc2cuZGF0YS5yZXNpemUpIHsnLFxuICAgICAgICAgICcgICAgU0laRS53aWR0aCA9IG1zZy5kYXRhLnJlc2l6ZS53aWR0aDsnLFxuICAgICAgICAgICcgICAgU0laRS5oZWlnaHQgPSBtc2cuZGF0YS5yZXNpemUuaGVpZ2h0OycsXG4gICAgICAgICAgJyAgfSBlbHNlIGlmIChtc2cuZGF0YS5jYW52YXMpIHsnLFxuICAgICAgICAgICcgICAgU0laRS53aWR0aCA9IG1zZy5kYXRhLmNhbnZhcy53aWR0aDsnLFxuICAgICAgICAgICcgICAgU0laRS5oZWlnaHQgPSBtc2cuZGF0YS5jYW52YXMuaGVpZ2h0OycsXG4gICAgICAgICAgJyAgICBDT05GRVRUSSA9IG1vZHVsZS5leHBvcnRzLmNyZWF0ZShtc2cuZGF0YS5jYW52YXMpOycsXG4gICAgICAgICAgJyAgfScsXG4gICAgICAgICAgJ30nLFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbY29kZV0pKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnNvbGUud2Fybign8J+OiiBDb3VsZCBub3QgbG9hZCB3b3JrZXInLCBlKSA6IG51bGw7XG5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlY29yYXRlKHdvcmtlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfTtcbiAgfSkoKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgcGFydGljbGVDb3VudDogNTAsXG4gICAgYW5nbGU6IDkwLFxuICAgIHNwcmVhZDogNDUsXG4gICAgc3RhcnRWZWxvY2l0eTogNDUsXG4gICAgZGVjYXk6IDAuOSxcbiAgICBncmF2aXR5OiAxLFxuICAgIGRyaWZ0OiAwLFxuICAgIHRpY2tzOiAyMDAsXG4gICAgeDogMC41LFxuICAgIHk6IDAuNSxcbiAgICBzaGFwZXM6IFsnc3F1YXJlJywgJ2NpcmNsZSddLFxuICAgIHpJbmRleDogMTAwLFxuICAgIGNvbG9yczogW1xuICAgICAgJyMyNmNjZmYnLFxuICAgICAgJyNhMjVhZmQnLFxuICAgICAgJyNmZjVlN2UnLFxuICAgICAgJyM4OGZmNWEnLFxuICAgICAgJyNmY2ZmNDInLFxuICAgICAgJyNmZmE2MmQnLFxuICAgICAgJyNmZjM2ZmYnXG4gICAgXSxcbiAgICAvLyBwcm9iYWJseSBzaG91bGQgYmUgdHJ1ZSwgYnV0IGJhY2stY29tcGF0XG4gICAgZGlzYWJsZUZvclJlZHVjZWRNb3Rpb246IGZhbHNlLFxuICAgIHNjYWxhcjogMVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbnZlcnQodmFsLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtID8gdHJhbnNmb3JtKHZhbCkgOiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc09rKHZhbCkge1xuICAgIHJldHVybiAhKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9wKG9wdGlvbnMsIG5hbWUsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBjb252ZXJ0KFxuICAgICAgb3B0aW9ucyAmJiBpc09rKG9wdGlvbnNbbmFtZV0pID8gb3B0aW9uc1tuYW1lXSA6IGRlZmF1bHRzW25hbWVdLFxuICAgICAgdHJhbnNmb3JtXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubHlQb3NpdGl2ZUludChudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgPCAwID8gMCA6IE1hdGguZmxvb3IobnVtYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xuICAgIC8vIFttaW4sIG1heClcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9EZWNpbWFsKHN0cikge1xuICAgIHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9yc1RvUmdiKGNvbG9ycykge1xuICAgIHJldHVybiBjb2xvcnMubWFwKGhleFRvUmdiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhleFRvUmdiKHN0cikge1xuICAgIHZhciB2YWwgPSBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bXjAtOWEtZl0vZ2ksICcnKTtcblxuICAgIGlmICh2YWwubGVuZ3RoIDwgNikge1xuICAgICAgICB2YWwgPSB2YWxbMF0rdmFsWzBdK3ZhbFsxXSt2YWxbMV0rdmFsWzJdK3ZhbFsyXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcjogdG9EZWNpbWFsKHZhbC5zdWJzdHJpbmcoMCwyKSksXG4gICAgICBnOiB0b0RlY2ltYWwodmFsLnN1YnN0cmluZygyLDQpKSxcbiAgICAgIGI6IHRvRGVjaW1hbCh2YWwuc3Vic3RyaW5nKDQsNikpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE9yaWdpbihvcHRpb25zKSB7XG4gICAgdmFyIG9yaWdpbiA9IHByb3Aob3B0aW9ucywgJ29yaWdpbicsIE9iamVjdCk7XG4gICAgb3JpZ2luLnggPSBwcm9wKG9yaWdpbiwgJ3gnLCBOdW1iZXIpO1xuICAgIG9yaWdpbi55ID0gcHJvcChvcmlnaW4sICd5JywgTnVtYmVyKTtcblxuICAgIHJldHVybiBvcmlnaW47XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYW52YXNXaW5kb3dTaXplKGNhbnZhcykge1xuICAgIGNhbnZhcy53aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhbnZhc1JlY3RTaXplKGNhbnZhcykge1xuICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2FudmFzKHpJbmRleCkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IHpJbmRleDtcblxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICBmdW5jdGlvbiBlbGxpcHNlKGNvbnRleHQsIHgsIHksIHJhZGl1c1gsIHJhZGl1c1ksIHJvdGF0aW9uLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSkge1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQucm90YXRlKHJvdGF0aW9uKTtcbiAgICBjb250ZXh0LnNjYWxlKHJhZGl1c1gsIHJhZGl1c1kpO1xuICAgIGNvbnRleHQuYXJjKDAsIDAsIDEsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKTtcbiAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmRvbVBoeXNpY3Mob3B0cykge1xuICAgIHZhciByYWRBbmdsZSA9IG9wdHMuYW5nbGUgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdmFyIHJhZFNwcmVhZCA9IG9wdHMuc3ByZWFkICogKE1hdGguUEkgLyAxODApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG9wdHMueCxcbiAgICAgIHk6IG9wdHMueSxcbiAgICAgIHdvYmJsZTogTWF0aC5yYW5kb20oKSAqIDEwLFxuICAgICAgd29iYmxlU3BlZWQ6IE1hdGgubWluKDAuMTEsIE1hdGgucmFuZG9tKCkgKiAwLjEgKyAwLjA1KSxcbiAgICAgIHZlbG9jaXR5OiAob3B0cy5zdGFydFZlbG9jaXR5ICogMC41KSArIChNYXRoLnJhbmRvbSgpICogb3B0cy5zdGFydFZlbG9jaXR5KSxcbiAgICAgIGFuZ2xlMkQ6IC1yYWRBbmdsZSArICgoMC41ICogcmFkU3ByZWFkKSAtIChNYXRoLnJhbmRvbSgpICogcmFkU3ByZWFkKSksXG4gICAgICB0aWx0QW5nbGU6IChNYXRoLnJhbmRvbSgpICogKDAuNzUgLSAwLjI1KSArIDAuMjUpICogTWF0aC5QSSxcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgc2hhcGU6IG9wdHMuc2hhcGUsXG4gICAgICB0aWNrOiAwLFxuICAgICAgdG90YWxUaWNrczogb3B0cy50aWNrcyxcbiAgICAgIGRlY2F5OiBvcHRzLmRlY2F5LFxuICAgICAgZHJpZnQ6IG9wdHMuZHJpZnQsXG4gICAgICByYW5kb206IE1hdGgucmFuZG9tKCkgKyAyLFxuICAgICAgdGlsdFNpbjogMCxcbiAgICAgIHRpbHRDb3M6IDAsXG4gICAgICB3b2JibGVYOiAwLFxuICAgICAgd29iYmxlWTogMCxcbiAgICAgIGdyYXZpdHk6IG9wdHMuZ3Jhdml0eSAqIDMsXG4gICAgICBvdmFsU2NhbGFyOiAwLjYsXG4gICAgICBzY2FsYXI6IG9wdHMuc2NhbGFyLFxuICAgICAgZmxhdDogb3B0cy5mbGF0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZldHRpKGNvbnRleHQsIGZldHRpKSB7XG4gICAgZmV0dGkueCArPSBNYXRoLmNvcyhmZXR0aS5hbmdsZTJEKSAqIGZldHRpLnZlbG9jaXR5ICsgZmV0dGkuZHJpZnQ7XG4gICAgZmV0dGkueSArPSBNYXRoLnNpbihmZXR0aS5hbmdsZTJEKSAqIGZldHRpLnZlbG9jaXR5ICsgZmV0dGkuZ3Jhdml0eTtcbiAgICBmZXR0aS52ZWxvY2l0eSAqPSBmZXR0aS5kZWNheTtcblxuICAgIGlmIChmZXR0aS5mbGF0KSB7XG4gICAgICBmZXR0aS53b2JibGUgPSAwO1xuICAgICAgZmV0dGkud29iYmxlWCA9IGZldHRpLnggKyAoMTAgKiBmZXR0aS5zY2FsYXIpO1xuICAgICAgZmV0dGkud29iYmxlWSA9IGZldHRpLnkgKyAoMTAgKiBmZXR0aS5zY2FsYXIpO1xuXG4gICAgICBmZXR0aS50aWx0U2luID0gMDtcbiAgICAgIGZldHRpLnRpbHRDb3MgPSAwO1xuICAgICAgZmV0dGkucmFuZG9tID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmV0dGkud29iYmxlICs9IGZldHRpLndvYmJsZVNwZWVkO1xuICAgICAgZmV0dGkud29iYmxlWCA9IGZldHRpLnggKyAoKDEwICogZmV0dGkuc2NhbGFyKSAqIE1hdGguY29zKGZldHRpLndvYmJsZSkpO1xuICAgICAgZmV0dGkud29iYmxlWSA9IGZldHRpLnkgKyAoKDEwICogZmV0dGkuc2NhbGFyKSAqIE1hdGguc2luKGZldHRpLndvYmJsZSkpO1xuXG4gICAgICBmZXR0aS50aWx0QW5nbGUgKz0gMC4xO1xuICAgICAgZmV0dGkudGlsdFNpbiA9IE1hdGguc2luKGZldHRpLnRpbHRBbmdsZSk7XG4gICAgICBmZXR0aS50aWx0Q29zID0gTWF0aC5jb3MoZmV0dGkudGlsdEFuZ2xlKTtcbiAgICAgIGZldHRpLnJhbmRvbSA9IE1hdGgucmFuZG9tKCkgKyAyO1xuICAgIH1cblxuICAgIHZhciBwcm9ncmVzcyA9IChmZXR0aS50aWNrKyspIC8gZmV0dGkudG90YWxUaWNrcztcblxuICAgIHZhciB4MSA9IGZldHRpLnggKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdENvcyk7XG4gICAgdmFyIHkxID0gZmV0dGkueSArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0U2luKTtcbiAgICB2YXIgeDIgPSBmZXR0aS53b2JibGVYICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRDb3MpO1xuICAgIHZhciB5MiA9IGZldHRpLndvYmJsZVkgKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdFNpbik7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBmZXR0aS5jb2xvci5yICsgJywgJyArIGZldHRpLmNvbG9yLmcgKyAnLCAnICsgZmV0dGkuY29sb3IuYiArICcsICcgKyAoMSAtIHByb2dyZXNzKSArICcpJztcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoY2FuVXNlUGF0aHMgJiYgZmV0dGkuc2hhcGUudHlwZSA9PT0gJ3BhdGgnICYmIHR5cGVvZiBmZXR0aS5zaGFwZS5wYXRoID09PSAnc3RyaW5nJyAmJiBBcnJheS5pc0FycmF5KGZldHRpLnNoYXBlLm1hdHJpeCkpIHtcbiAgICAgIGNvbnRleHQuZmlsbCh0cmFuc2Zvcm1QYXRoMkQoXG4gICAgICAgIGZldHRpLnNoYXBlLnBhdGgsXG4gICAgICAgIGZldHRpLnNoYXBlLm1hdHJpeCxcbiAgICAgICAgZmV0dGkueCxcbiAgICAgICAgZmV0dGkueSxcbiAgICAgICAgTWF0aC5hYnMoeDIgLSB4MSkgKiAwLjEsXG4gICAgICAgIE1hdGguYWJzKHkyIC0geTEpICogMC4xLFxuICAgICAgICBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGVcbiAgICAgICkpO1xuICAgIH0gZWxzZSBpZiAoZmV0dGkuc2hhcGUudHlwZSA9PT0gJ2JpdG1hcCcpIHtcbiAgICAgIHZhciByb3RhdGlvbiA9IE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZTtcbiAgICAgIHZhciBzY2FsZVggPSBNYXRoLmFicyh4MiAtIHgxKSAqIDAuMTtcbiAgICAgIHZhciBzY2FsZVkgPSBNYXRoLmFicyh5MiAtIHkxKSAqIDAuMTtcbiAgICAgIHZhciB3aWR0aCA9IGZldHRpLnNoYXBlLmJpdG1hcC53aWR0aCAqIGZldHRpLnNjYWxhcjtcbiAgICAgIHZhciBoZWlnaHQgPSBmZXR0aS5zaGFwZS5iaXRtYXAuaGVpZ2h0ICogZmV0dGkuc2NhbGFyO1xuXG4gICAgICB2YXIgbWF0cml4ID0gbmV3IERPTU1hdHJpeChbXG4gICAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgICAgTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYLFxuICAgICAgICAtTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVZLFxuICAgICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICAgIGZldHRpLngsXG4gICAgICAgIGZldHRpLnlcbiAgICAgIF0pO1xuXG4gICAgICAvLyBhcHBseSB0aGUgdHJhbnNmb3JtIG1hdHJpeCBmcm9tIHRoZSBjb25mZXR0aSBzaGFwZVxuICAgICAgbWF0cml4Lm11bHRpcGx5U2VsZihuZXcgRE9NTWF0cml4KGZldHRpLnNoYXBlLm1hdHJpeCkpO1xuXG4gICAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybihiaXRtYXBNYXBwZXIudHJhbnNmb3JtKGZldHRpLnNoYXBlLmJpdG1hcCksICduby1yZXBlYXQnKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKG1hdHJpeCk7XG5cbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAoMSAtIHByb2dyZXNzKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgIGZldHRpLnggLSAod2lkdGggLyAyKSxcbiAgICAgICAgZmV0dGkueSAtIChoZWlnaHQgLyAyKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgKTtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuICAgIH0gZWxzZSBpZiAoZmV0dGkuc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgICBjb250ZXh0LmVsbGlwc2UgP1xuICAgICAgICBjb250ZXh0LmVsbGlwc2UoZmV0dGkueCwgZmV0dGkueSwgTWF0aC5hYnMoeDIgLSB4MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLmFicyh5MiAtIHkxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZSwgMCwgMiAqIE1hdGguUEkpIDpcbiAgICAgICAgZWxsaXBzZShjb250ZXh0LCBmZXR0aS54LCBmZXR0aS55LCBNYXRoLmFicyh4MiAtIHgxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguYWJzKHkyIC0geTEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5QSSAvIDEwICogZmV0dGkud29iYmxlLCAwLCAyICogTWF0aC5QSSk7XG4gICAgfSBlbHNlIGlmIChmZXR0aS5zaGFwZSA9PT0gJ3N0YXInKSB7XG4gICAgICB2YXIgcm90ID0gTWF0aC5QSSAvIDIgKiAzO1xuICAgICAgdmFyIGlubmVyUmFkaXVzID0gNCAqIGZldHRpLnNjYWxhcjtcbiAgICAgIHZhciBvdXRlclJhZGl1cyA9IDggKiBmZXR0aS5zY2FsYXI7XG4gICAgICB2YXIgeCA9IGZldHRpLng7XG4gICAgICB2YXIgeSA9IGZldHRpLnk7XG4gICAgICB2YXIgc3Bpa2VzID0gNTtcbiAgICAgIHZhciBzdGVwID0gTWF0aC5QSSAvIHNwaWtlcztcblxuICAgICAgd2hpbGUgKHNwaWtlcy0tKSB7XG4gICAgICAgIHggPSBmZXR0aS54ICsgTWF0aC5jb3Mocm90KSAqIG91dGVyUmFkaXVzO1xuICAgICAgICB5ID0gZmV0dGkueSArIE1hdGguc2luKHJvdCkgKiBvdXRlclJhZGl1cztcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHJvdCArPSBzdGVwO1xuXG4gICAgICAgIHggPSBmZXR0aS54ICsgTWF0aC5jb3Mocm90KSAqIGlubmVyUmFkaXVzO1xuICAgICAgICB5ID0gZmV0dGkueSArIE1hdGguc2luKHJvdCkgKiBpbm5lclJhZGl1cztcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIHJvdCArPSBzdGVwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhNYXRoLmZsb29yKGZldHRpLngpLCBNYXRoLmZsb29yKGZldHRpLnkpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKE1hdGguZmxvb3IoZmV0dGkud29iYmxlWCksIE1hdGguZmxvb3IoeTEpKTtcbiAgICAgIGNvbnRleHQubGluZVRvKE1hdGguZmxvb3IoeDIpLCBNYXRoLmZsb29yKHkyKSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKHgxKSwgTWF0aC5mbG9vcihmZXR0aS53b2JibGVZKSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgIHJldHVybiBmZXR0aS50aWNrIDwgZmV0dGkudG90YWxUaWNrcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUoY2FudmFzLCBmZXR0aXMsIHJlc2l6ZXIsIHNpemUsIGRvbmUpIHtcbiAgICB2YXIgYW5pbWF0aW5nRmV0dGlzID0gZmV0dGlzLnNsaWNlKCk7XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgYW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGRlc3Ryb3k7XG5cbiAgICB2YXIgcHJvbSA9IHByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGZ1bmN0aW9uIG9uRG9uZSgpIHtcbiAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSBkZXN0cm95ID0gbnVsbDtcblxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgIGJpdG1hcE1hcHBlci5jbGVhcigpO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmIChpc1dvcmtlciAmJiAhKHNpemUud2lkdGggPT09IHdvcmtlclNpemUud2lkdGggJiYgc2l6ZS5oZWlnaHQgPT09IHdvcmtlclNpemUuaGVpZ2h0KSkge1xuICAgICAgICAgIHNpemUud2lkdGggPSBjYW52YXMud2lkdGggPSB3b3JrZXJTaXplLndpZHRoO1xuICAgICAgICAgIHNpemUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHdvcmtlclNpemUuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaXplLndpZHRoICYmICFzaXplLmhlaWdodCkge1xuICAgICAgICAgIHJlc2l6ZXIoY2FudmFzKTtcbiAgICAgICAgICBzaXplLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgIHNpemUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgICBhbmltYXRpbmdGZXR0aXMgPSBhbmltYXRpbmdGZXR0aXMuZmlsdGVyKGZ1bmN0aW9uIChmZXR0aSkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVGZXR0aShjb250ZXh0LCBmZXR0aSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhbmltYXRpbmdGZXR0aXMubGVuZ3RoKSB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSByYWYuZnJhbWUodXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25GcmFtZSA9IHJhZi5mcmFtZSh1cGRhdGUpO1xuICAgICAgZGVzdHJveSA9IG9uRG9uZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZGRGZXR0aXM6IGZ1bmN0aW9uIChmZXR0aXMpIHtcbiAgICAgICAgYW5pbWF0aW5nRmV0dGlzID0gYW5pbWF0aW5nRmV0dGlzLmNvbmNhdChmZXR0aXMpO1xuXG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgfSxcbiAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgcHJvbWlzZTogcHJvbSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHJhZi5jYW5jZWwoYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmV0dGlDYW5ub24oY2FudmFzLCBnbG9iYWxPcHRzKSB7XG4gICAgdmFyIGlzTGliQ2FudmFzID0gIWNhbnZhcztcbiAgICB2YXIgYWxsb3dSZXNpemUgPSAhIXByb3AoZ2xvYmFsT3B0cyB8fCB7fSwgJ3Jlc2l6ZScpO1xuICAgIHZhciBoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICB2YXIgZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gPSBwcm9wKGdsb2JhbE9wdHMsICdkaXNhYmxlRm9yUmVkdWNlZE1vdGlvbicsIEJvb2xlYW4pO1xuICAgIHZhciBzaG91bGRVc2VXb3JrZXIgPSBjYW5Vc2VXb3JrZXIgJiYgISFwcm9wKGdsb2JhbE9wdHMgfHwge30sICd1c2VXb3JrZXInKTtcbiAgICB2YXIgd29ya2VyID0gc2hvdWxkVXNlV29ya2VyID8gZ2V0V29ya2VyKCkgOiBudWxsO1xuICAgIHZhciByZXNpemVyID0gaXNMaWJDYW52YXMgPyBzZXRDYW52YXNXaW5kb3dTaXplIDogc2V0Q2FudmFzUmVjdFNpemU7XG4gICAgdmFyIGluaXRpYWxpemVkID0gKGNhbnZhcyAmJiB3b3JrZXIpID8gISFjYW52YXMuX19jb25mZXR0aV9pbml0aWFsaXplZCA6IGZhbHNlO1xuICAgIHZhciBwcmVmZXJMZXNzTW90aW9uID0gdHlwZW9mIG1hdGNoTWVkaWEgPT09ICdmdW5jdGlvbicgJiYgbWF0Y2hNZWRpYSgnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pJykubWF0Y2hlcztcbiAgICB2YXIgYW5pbWF0aW9uT2JqO1xuXG4gICAgZnVuY3Rpb24gZmlyZUxvY2FsKG9wdGlvbnMsIHNpemUsIGRvbmUpIHtcbiAgICAgIHZhciBwYXJ0aWNsZUNvdW50ID0gcHJvcChvcHRpb25zLCAncGFydGljbGVDb3VudCcsIG9ubHlQb3NpdGl2ZUludCk7XG4gICAgICB2YXIgYW5nbGUgPSBwcm9wKG9wdGlvbnMsICdhbmdsZScsIE51bWJlcik7XG4gICAgICB2YXIgc3ByZWFkID0gcHJvcChvcHRpb25zLCAnc3ByZWFkJywgTnVtYmVyKTtcbiAgICAgIHZhciBzdGFydFZlbG9jaXR5ID0gcHJvcChvcHRpb25zLCAnc3RhcnRWZWxvY2l0eScsIE51bWJlcik7XG4gICAgICB2YXIgZGVjYXkgPSBwcm9wKG9wdGlvbnMsICdkZWNheScsIE51bWJlcik7XG4gICAgICB2YXIgZ3Jhdml0eSA9IHByb3Aob3B0aW9ucywgJ2dyYXZpdHknLCBOdW1iZXIpO1xuICAgICAgdmFyIGRyaWZ0ID0gcHJvcChvcHRpb25zLCAnZHJpZnQnLCBOdW1iZXIpO1xuICAgICAgdmFyIGNvbG9ycyA9IHByb3Aob3B0aW9ucywgJ2NvbG9ycycsIGNvbG9yc1RvUmdiKTtcbiAgICAgIHZhciB0aWNrcyA9IHByb3Aob3B0aW9ucywgJ3RpY2tzJywgTnVtYmVyKTtcbiAgICAgIHZhciBzaGFwZXMgPSBwcm9wKG9wdGlvbnMsICdzaGFwZXMnKTtcbiAgICAgIHZhciBzY2FsYXIgPSBwcm9wKG9wdGlvbnMsICdzY2FsYXInKTtcbiAgICAgIHZhciBmbGF0ID0gISFwcm9wKG9wdGlvbnMsICdmbGF0Jyk7XG4gICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKG9wdGlvbnMpO1xuXG4gICAgICB2YXIgdGVtcCA9IHBhcnRpY2xlQ291bnQ7XG4gICAgICB2YXIgZmV0dGlzID0gW107XG5cbiAgICAgIHZhciBzdGFydFggPSBjYW52YXMud2lkdGggKiBvcmlnaW4ueDtcbiAgICAgIHZhciBzdGFydFkgPSBjYW52YXMuaGVpZ2h0ICogb3JpZ2luLnk7XG5cbiAgICAgIHdoaWxlICh0ZW1wLS0pIHtcbiAgICAgICAgZmV0dGlzLnB1c2goXG4gICAgICAgICAgcmFuZG9tUGh5c2ljcyh7XG4gICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICB5OiBzdGFydFksXG4gICAgICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgICAgICBzcHJlYWQ6IHNwcmVhZCxcbiAgICAgICAgICAgIHN0YXJ0VmVsb2NpdHk6IHN0YXJ0VmVsb2NpdHksXG4gICAgICAgICAgICBjb2xvcjogY29sb3JzW3RlbXAgJSBjb2xvcnMubGVuZ3RoXSxcbiAgICAgICAgICAgIHNoYXBlOiBzaGFwZXNbcmFuZG9tSW50KDAsIHNoYXBlcy5sZW5ndGgpXSxcbiAgICAgICAgICAgIHRpY2tzOiB0aWNrcyxcbiAgICAgICAgICAgIGRlY2F5OiBkZWNheSxcbiAgICAgICAgICAgIGdyYXZpdHk6IGdyYXZpdHksXG4gICAgICAgICAgICBkcmlmdDogZHJpZnQsXG4gICAgICAgICAgICBzY2FsYXI6IHNjYWxhcixcbiAgICAgICAgICAgIGZsYXQ6IGZsYXRcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgcHJldmlvdXMgY2FudmFzIGFscmVhZHkgYW5pbWF0aW5nLFxuICAgICAgLy8gYWRkIHRvIGl0XG4gICAgICBpZiAoYW5pbWF0aW9uT2JqKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25PYmouYWRkRmV0dGlzKGZldHRpcyk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbk9iaiA9IGFuaW1hdGUoY2FudmFzLCBmZXR0aXMsIHJlc2l6ZXIsIHNpemUgLCBkb25lKTtcblxuICAgICAgcmV0dXJuIGFuaW1hdGlvbk9iai5wcm9taXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmUob3B0aW9ucykge1xuICAgICAgdmFyIGRpc2FibGVGb3JSZWR1Y2VkTW90aW9uID0gZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gfHwgcHJvcChvcHRpb25zLCAnZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24nLCBCb29sZWFuKTtcbiAgICAgIHZhciB6SW5kZXggPSBwcm9wKG9wdGlvbnMsICd6SW5kZXgnLCBOdW1iZXIpO1xuXG4gICAgICBpZiAoZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gJiYgcHJlZmVyTGVzc01vdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xpYkNhbnZhcyAmJiBhbmltYXRpb25PYmopIHtcbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIGNhbnZhcyBmcm9tIGluLXByb2dyZXNzIGFuaW1hdGlvblxuICAgICAgICBjYW52YXMgPSBhbmltYXRpb25PYmouY2FudmFzO1xuICAgICAgfSBlbHNlIGlmIChpc0xpYkNhbnZhcyAmJiAhY2FudmFzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIG5ldyBjYW52YXNcbiAgICAgICAgY2FudmFzID0gZ2V0Q2FudmFzKHpJbmRleCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93UmVzaXplICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXplIG9mIGEgdXNlci1zdXBwbGllZCBjYW52YXNcbiAgICAgICAgcmVzaXplcihjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICBpZiAod29ya2VyICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICB3b3JrZXIuaW5pdChjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgY2FudmFzLl9fY29uZmV0dGlfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgIC8vIFRPRE8gdGhpcyByZWFsbHkgc2hvdWxkbid0IGJlIGltbWVkaWF0ZSwgYmVjYXVzZSBpdCBpcyBleHBlbnNpdmVcbiAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghaXNMaWJDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJlc2l6ZXIob2JqKTtcblxuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IG9iai53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBvYmouaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgcXVlcnkgdGhlIHNpemUgaGVyZSwgc2luY2UgdGhpc1xuICAgICAgICAvLyBjYW4gZXhlY3V0ZSBmcmVxdWVudGx5IGFuZCByYXBpZGx5XG4gICAgICAgIHNpemUud2lkdGggPSBzaXplLmhlaWdodCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIGFuaW1hdGlvbk9iaiA9IG51bGw7XG5cbiAgICAgICAgaWYgKGFsbG93UmVzaXplKSB7XG4gICAgICAgICAgaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xpYkNhbnZhcyAmJiBjYW52YXMpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNhbnZhcyk7IFxuICAgICAgICAgIH1cbiAgICAgICAgICBjYW52YXMgPSBudWxsO1xuICAgICAgICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93UmVzaXplICYmICFoYXNSZXNpemVFdmVudFJlZ2lzdGVyZWQpIHtcbiAgICAgICAgaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgcmV0dXJuIHdvcmtlci5maXJlKG9wdGlvbnMsIHNpemUsIGRvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlyZUxvY2FsKG9wdGlvbnMsIHNpemUsIGRvbmUpO1xuICAgIH1cblxuICAgIGZpcmUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod29ya2VyKSB7XG4gICAgICAgIHdvcmtlci5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0aW9uT2JqKSB7XG4gICAgICAgIGFuaW1hdGlvbk9iai5yZXNldCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZmlyZTtcbiAgfVxuXG4gIC8vIE1ha2UgZGVmYXVsdCBleHBvcnQgbGF6eSB0byBkZWZlciB3b3JrZXIgY3JlYXRpb24gdW50aWwgY2FsbGVkLlxuICB2YXIgZGVmYXVsdEZpcmU7XG4gIGZ1bmN0aW9uIGdldERlZmF1bHRGaXJlKCkge1xuICAgIGlmICghZGVmYXVsdEZpcmUpIHtcbiAgICAgIGRlZmF1bHRGaXJlID0gY29uZmV0dGlDYW5ub24obnVsbCwgeyB1c2VXb3JrZXI6IHRydWUsIHJlc2l6ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRGaXJlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUGF0aDJEKHBhdGhTdHJpbmcsIHBhdGhNYXRyaXgsIHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbikge1xuICAgIHZhciBwYXRoMmQgPSBuZXcgUGF0aDJEKHBhdGhTdHJpbmcpO1xuXG4gICAgdmFyIHQxID0gbmV3IFBhdGgyRCgpO1xuICAgIHQxLmFkZFBhdGgocGF0aDJkLCBuZXcgRE9NTWF0cml4KHBhdGhNYXRyaXgpKTtcblxuICAgIHZhciB0MiA9IG5ldyBQYXRoMkQoKTtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTU1hdHJpeC9ET01NYXRyaXhcbiAgICB0Mi5hZGRQYXRoKHQxLCBuZXcgRE9NTWF0cml4KFtcbiAgICAgIE1hdGguY29zKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgIE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWCxcbiAgICAgIC1NYXRoLnNpbihyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVksXG4gICAgICB4LFxuICAgICAgeVxuICAgIF0pKTtcblxuICAgIHJldHVybiB0MjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXBlRnJvbVBhdGgocGF0aERhdGEpIHtcbiAgICBpZiAoIWNhblVzZVBhdGhzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggY29uZmV0dGkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgdmFyIHBhdGgsIG1hdHJpeDtcblxuICAgIGlmICh0eXBlb2YgcGF0aERhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXRoID0gcGF0aERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBwYXRoRGF0YS5wYXRoO1xuICAgICAgbWF0cml4ID0gcGF0aERhdGEubWF0cml4O1xuICAgIH1cblxuICAgIHZhciBwYXRoMmQgPSBuZXcgUGF0aDJEKHBhdGgpO1xuICAgIHZhciB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIHRlbXBDdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICBpZiAoIW1hdHJpeCkge1xuICAgICAgLy8gYXR0ZW1wdCB0byBmaWd1cmUgb3V0IHRoZSB3aWR0aCBvZiB0aGUgcGF0aCwgdXAgdG8gMTAwMHgxMDAwXG4gICAgICB2YXIgbWF4U2l6ZSA9IDEwMDA7XG4gICAgICB2YXIgbWluWCA9IG1heFNpemU7XG4gICAgICB2YXIgbWluWSA9IG1heFNpemU7XG4gICAgICB2YXIgbWF4WCA9IDA7XG4gICAgICB2YXIgbWF4WSA9IDA7XG4gICAgICB2YXIgd2lkdGgsIGhlaWdodDtcblxuICAgICAgLy8gZG8gc29tZSBsaW5lIHNraXBwaW5nLi4uIHRoaXMgaXMgZmFzdGVyIHRoYW4gY2hlY2tpbmdcbiAgICAgIC8vIGV2ZXJ5IHBpeGVsIGFuZCB3aWxsIGJlIG1vc3RseSBzdGlsbCBjb3JyZWN0XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heFNpemU7IHggKz0gMikge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IG1heFNpemU7IHkgKz0gMikge1xuICAgICAgICAgIGlmICh0ZW1wQ3R4LmlzUG9pbnRJblBhdGgocGF0aDJkLCB4LCB5LCAnbm9uemVybycpKSB7XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdpZHRoID0gbWF4WCAtIG1pblg7XG4gICAgICBoZWlnaHQgPSBtYXhZIC0gbWluWTtcblxuICAgICAgdmFyIG1heERlc2lyZWRTaXplID0gMTA7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbihtYXhEZXNpcmVkU2l6ZS93aWR0aCwgbWF4RGVzaXJlZFNpemUvaGVpZ2h0KTtcblxuICAgICAgbWF0cml4ID0gW1xuICAgICAgICBzY2FsZSwgMCwgMCwgc2NhbGUsXG4gICAgICAgIC1NYXRoLnJvdW5kKCh3aWR0aC8yKSArIG1pblgpICogc2NhbGUsXG4gICAgICAgIC1NYXRoLnJvdW5kKChoZWlnaHQvMikgKyBtaW5ZKSAqIHNjYWxlXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAncGF0aCcsXG4gICAgICBwYXRoOiBwYXRoLFxuICAgICAgbWF0cml4OiBtYXRyaXhcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcGVGcm9tVGV4dCh0ZXh0RGF0YSkge1xuICAgIHZhciB0ZXh0LFxuICAgICAgICBzY2FsYXIgPSAxLFxuICAgICAgICBjb2xvciA9ICcjMDAwMDAwJyxcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vbm9sYW5sYXdzb24uY29tLzIwMjIvMDQvMDgvdGhlLXN0cnVnZ2xlLW9mLXVzaW5nLW5hdGl2ZS1lbW9qaS1vbi10aGUtd2ViL1xuICAgICAgICBmb250RmFtaWx5ID0gJ1wiQXBwbGUgQ29sb3IgRW1vamlcIiwgXCJTZWdvZSBVSSBFbW9qaVwiLCBcIlNlZ29lIFVJIFN5bWJvbFwiLCBcIk5vdG8gQ29sb3IgRW1vamlcIiwgXCJFbW9qaU9uZSBDb2xvclwiLCBcIkFuZHJvaWQgRW1vamlcIiwgXCJUd2Vtb2ppIE1vemlsbGFcIiwgXCJzeXN0ZW0gZW1vamlcIiwgc2Fucy1zZXJpZic7XG5cbiAgICBpZiAodHlwZW9mIHRleHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdGV4dCA9IHRleHREYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0ID0gdGV4dERhdGEudGV4dDtcbiAgICAgIHNjYWxhciA9ICdzY2FsYXInIGluIHRleHREYXRhID8gdGV4dERhdGEuc2NhbGFyIDogc2NhbGFyO1xuICAgICAgZm9udEZhbWlseSA9ICdmb250RmFtaWx5JyBpbiB0ZXh0RGF0YSA/IHRleHREYXRhLmZvbnRGYW1pbHkgOiBmb250RmFtaWx5O1xuICAgICAgY29sb3IgPSAnY29sb3InIGluIHRleHREYXRhID8gdGV4dERhdGEuY29sb3IgOiBjb2xvcjtcbiAgICB9XG5cbiAgICAvLyBhbGwgb3RoZXIgY29uZmV0dGkgYXJlIDEwIHBpeGVscyxcbiAgICAvLyBzbyB0aGlzIHBpeGVsIHNpemUgaXMgdGhlIGRlLWZhY3RvIDEwMCUgc2NhbGUgY29uZmV0dGlcbiAgICB2YXIgZm9udFNpemUgPSAxMCAqIHNjYWxhcjtcbiAgICB2YXIgZm9udCA9ICcnICsgZm9udFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG5cbiAgICB2YXIgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhmb250U2l6ZSwgZm9udFNpemUpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGN0eC5mb250ID0gZm9udDtcbiAgICB2YXIgc2l6ZSA9IGN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoc2l6ZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0ICsgc2l6ZS5hY3R1YWxCb3VuZGluZ0JveExlZnQpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLmNlaWwoc2l6ZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCArIHNpemUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KTtcblxuICAgIHZhciBwYWRkaW5nID0gMjtcbiAgICB2YXIgeCA9IHNpemUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0ICsgcGFkZGluZztcbiAgICB2YXIgeSA9IHNpemUuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQgKyBwYWRkaW5nO1xuICAgIHdpZHRoICs9IHBhZGRpbmcgKyBwYWRkaW5nO1xuICAgIGhlaWdodCArPSBwYWRkaW5nICsgcGFkZGluZztcblxuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmZvbnQgPSBmb250O1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcblxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcblxuICAgIHZhciBzY2FsZSA9IDEgLyBzY2FsYXI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2JpdG1hcCcsXG4gICAgICAvLyBUT0RPIHRoZXNlIHByb2JhYmx5IG5lZWQgdG8gYmUgdHJhbnNmZXJlZCBmb3Igd29ya2Vyc1xuICAgICAgYml0bWFwOiBjYW52YXMudHJhbnNmZXJUb0ltYWdlQml0bWFwKCksXG4gICAgICBtYXRyaXg6IFtzY2FsZSwgMCwgMCwgc2NhbGUsIC13aWR0aCAqIHNjYWxlIC8gMiwgLWhlaWdodCAqIHNjYWxlIC8gMl1cbiAgICB9O1xuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0RGVmYXVsdEZpcmUoKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cy5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIGdldERlZmF1bHRGaXJlKCkucmVzZXQoKTtcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMuY3JlYXRlID0gY29uZmV0dGlDYW5ub247XG4gIG1vZHVsZS5leHBvcnRzLnNoYXBlRnJvbVBhdGggPSBzaGFwZUZyb21QYXRoO1xuICBtb2R1bGUuZXhwb3J0cy5zaGFwZUZyb21UZXh0ID0gc2hhcGVGcm9tVGV4dDtcbn0oKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHJldHVybiB0aGlzIHx8IHt9O1xufSkoKSwgbW9kdWxlLCBmYWxzZSkpO1xuXG4vLyBlbmQgc291cmNlIGNvbnRlbnRcblxuZXhwb3J0IGRlZmF1bHQgbW9kdWxlLmV4cG9ydHM7XG5leHBvcnQgdmFyIGNyZWF0ZSA9IG1vZHVsZS5leHBvcnRzLmNyZWF0ZTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJtYWluIiwiZ2xvYmFsIiwiaXNXb3JrZXIiLCJ3b3JrZXJTaXplIiwiY2FuVXNlV29ya2VyIiwiV29ya2VyIiwiQmxvYiIsIlByb21pc2UiLCJPZmZzY3JlZW5DYW52YXMiLCJPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQiLCJIVE1MQ2FudmFzRWxlbWVudCIsInByb3RvdHlwZSIsInRyYW5zZmVyQ29udHJvbFRvT2Zmc2NyZWVuIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiY2FuVXNlUGF0aHMiLCJQYXRoMkQiLCJET01NYXRyaXgiLCJjYW5EcmF3Qml0bWFwIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxSZWN0IiwiYml0bWFwIiwidHJhbnNmZXJUb0ltYWdlQml0bWFwIiwiY3JlYXRlUGF0dGVybiIsImUiLCJub29wIiwicHJvbWlzZSIsImZ1bmMiLCJNb2R1bGVQcm9taXNlIiwiZXhwb3J0cyIsIlByb20iLCJiaXRtYXBNYXBwZXIiLCJza2lwVHJhbnNmb3JtIiwibWFwIiwidHJhbnNmb3JtIiwiaGFzIiwiZ2V0Iiwid2lkdGgiLCJoZWlnaHQiLCJkcmF3SW1hZ2UiLCJzZXQiLCJjbGVhciIsIk1hcCIsInJhZiIsIlRJTUUiLCJNYXRoIiwiZmxvb3IiLCJmcmFtZSIsImNhbmNlbCIsImZyYW1lcyIsImxhc3RGcmFtZVRpbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNiIiwiaWQiLCJyYW5kb20iLCJvbkZyYW1lIiwidGltZSIsInNldFRpbWVvdXQiLCJ0aW1lciIsImNsZWFyVGltZW91dCIsImdldFdvcmtlciIsIndvcmtlciIsInByb20iLCJyZXNvbHZlcyIsImRlY29yYXRlIiwiZXhlY3V0ZSIsIm9wdGlvbnMiLCJjYWxsYmFjayIsInBvc3RNZXNzYWdlIiwiaW5pdCIsImluaXRXb3JrZXIiLCJvZmZzY3JlZW4iLCJmaXJlIiwiZmlyZVdvcmtlciIsInNpemUiLCJkb25lIiwidG9TdHJpbmciLCJzbGljZSIsInJlc29sdmUiLCJ3b3JrZXJEb25lIiwibXNnIiwiZGF0YSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiYmluZCIsInJlc2V0IiwicmVzZXRXb3JrZXIiLCJjb2RlIiwiam9pbiIsImNvbnNvbGUiLCJ1bmRlZmluZWQiLCJ3YXJuIiwiZGVmYXVsdHMiLCJwYXJ0aWNsZUNvdW50IiwiYW5nbGUiLCJzcHJlYWQiLCJzdGFydFZlbG9jaXR5IiwiZGVjYXkiLCJncmF2aXR5IiwiZHJpZnQiLCJ0aWNrcyIsIngiLCJ5Iiwic2hhcGVzIiwiekluZGV4IiwiY29sb3JzIiwiZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24iLCJzY2FsYXIiLCJjb252ZXJ0IiwidmFsIiwiaXNPayIsInByb3AiLCJuYW1lIiwib25seVBvc2l0aXZlSW50IiwibnVtYmVyIiwicmFuZG9tSW50IiwibWluIiwibWF4IiwidG9EZWNpbWFsIiwic3RyIiwicGFyc2VJbnQiLCJjb2xvcnNUb1JnYiIsImhleFRvUmdiIiwiU3RyaW5nIiwicmVwbGFjZSIsImxlbmd0aCIsInIiLCJzdWJzdHJpbmciLCJnIiwiYiIsImdldE9yaWdpbiIsIm9yaWdpbiIsIk9iamVjdCIsIk51bWJlciIsInNldENhbnZhc1dpbmRvd1NpemUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Iiwic2V0Q2FudmFzUmVjdFNpemUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q2FudmFzIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwicG9pbnRlckV2ZW50cyIsImVsbGlwc2UiLCJjb250ZXh0IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbiIsInN0YXJ0QW5nbGUiLCJlbmRBbmdsZSIsImFudGlDbG9ja3dpc2UiLCJzYXZlIiwidHJhbnNsYXRlIiwicm90YXRlIiwic2NhbGUiLCJhcmMiLCJyZXN0b3JlIiwicmFuZG9tUGh5c2ljcyIsIm9wdHMiLCJyYWRBbmdsZSIsIlBJIiwicmFkU3ByZWFkIiwid29iYmxlIiwid29iYmxlU3BlZWQiLCJ2ZWxvY2l0eSIsImFuZ2xlMkQiLCJ0aWx0QW5nbGUiLCJjb2xvciIsInNoYXBlIiwidGljayIsInRvdGFsVGlja3MiLCJ0aWx0U2luIiwidGlsdENvcyIsIndvYmJsZVgiLCJ3b2JibGVZIiwib3ZhbFNjYWxhciIsImZsYXQiLCJ1cGRhdGVGZXR0aSIsImZldHRpIiwiY29zIiwic2luIiwicHJvZ3Jlc3MiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImZpbGxTdHlsZSIsImJlZ2luUGF0aCIsInR5cGUiLCJwYXRoIiwiQXJyYXkiLCJpc0FycmF5IiwibWF0cml4IiwiZmlsbCIsInRyYW5zZm9ybVBhdGgyRCIsImFicyIsInNjYWxlWCIsInNjYWxlWSIsIm11bHRpcGx5U2VsZiIsInBhdHRlcm4iLCJzZXRUcmFuc2Zvcm0iLCJnbG9iYWxBbHBoYSIsInJvdCIsImlubmVyUmFkaXVzIiwib3V0ZXJSYWRpdXMiLCJzcGlrZXMiLCJzdGVwIiwibGluZVRvIiwibW92ZVRvIiwiY2xvc2VQYXRoIiwiYW5pbWF0ZSIsImZldHRpcyIsInJlc2l6ZXIiLCJhbmltYXRpbmdGZXR0aXMiLCJhbmltYXRpb25GcmFtZSIsImRlc3Ryb3kiLCJvbkRvbmUiLCJjbGVhclJlY3QiLCJ1cGRhdGUiLCJmaWx0ZXIiLCJhZGRGZXR0aXMiLCJjb25jYXQiLCJjb25mZXR0aUNhbm5vbiIsImdsb2JhbE9wdHMiLCJpc0xpYkNhbnZhcyIsImFsbG93UmVzaXplIiwiaGFzUmVzaXplRXZlbnRSZWdpc3RlcmVkIiwiZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24iLCJCb29sZWFuIiwic2hvdWxkVXNlV29ya2VyIiwiaW5pdGlhbGl6ZWQiLCJfX2NvbmZldHRpX2luaXRpYWxpemVkIiwicHJlZmVyTGVzc01vdGlvbiIsIm1hdGNoTWVkaWEiLCJtYXRjaGVzIiwiYW5pbWF0aW9uT2JqIiwiZmlyZUxvY2FsIiwidGVtcCIsInN0YXJ0WCIsInN0YXJ0WSIsInB1c2giLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJvblJlc2l6ZSIsIm9iaiIsInJlc2l6ZSIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJkZWZhdWx0RmlyZSIsImdldERlZmF1bHRGaXJlIiwidXNlV29ya2VyIiwicGF0aFN0cmluZyIsInBhdGhNYXRyaXgiLCJwYXRoMmQiLCJ0MSIsImFkZFBhdGgiLCJ0MiIsInNoYXBlRnJvbVBhdGgiLCJwYXRoRGF0YSIsIkVycm9yIiwidGVtcENhbnZhcyIsInRlbXBDdHgiLCJtYXhTaXplIiwibWluWCIsIm1pblkiLCJtYXhYIiwibWF4WSIsImlzUG9pbnRJblBhdGgiLCJtYXhEZXNpcmVkU2l6ZSIsInJvdW5kIiwic2hhcGVGcm9tVGV4dCIsInRleHREYXRhIiwidGV4dCIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnQiLCJtZWFzdXJlVGV4dCIsImNlaWwiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJwYWRkaW5nIiwiZmlsbFRleHQiLCJhcHBseSIsImFyZ3VtZW50cyIsImNyZWF0ZSIsIndpbmRvdyIsInNlbGYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-confetti/dist/confetti.module.mjs\n");

/***/ })

};
;